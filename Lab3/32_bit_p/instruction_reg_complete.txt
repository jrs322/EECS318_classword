THIS SECTION IS FOR TESTS


THIS IS FOR MULTIPLICATION
reg[31:0] is0 =  32'b00000000000000000000000000000000;
reg[31:0] is1 =  32'b00101000000000001010000000000000; //store a = -15 into mem 0
reg[31:0] is2 =  32'b00101000000001001001000000000001; //store b =  -3 into mem 1
reg[31:0] is3 =  32'b00010000000000000000000000000000; //loading mem  into reg 0
reg[31:0] is4 =  32'b00010000000000000000000000000001; //loading mem 1 into reg 1
reg[31:0] is5 =  32'b00110100000000000000000000001010; //branch if reg 1 negative to is10
reg[31:0] is6 =  32'b00110101000000000000000000001101; //branch if reg 1 = 0 to is13
reg[31:0] is7 =  32'b01010000000000000000000000000000; //add reg 0 to reg 0
reg[31:0] is8 =  32'b01011000111111111111000000000001; //add -1 to reg 1
reg[31:0] is9 =  32'b00110000000000000000000000000110; //branch always to is6
reg[31:0] is10 = 32'b10010000000000000001000000000001; //complement reg 1 to reg 1
reg[31:0] is11 = 32'b01011000000000000010000000000001; //add 2 to reg 1
reg[31:0] is12 = 32'b00110000000000000000000000000110; //branch always to is6
reg[31:0] is13 = 32'b00100000000000000000000000000010; //store reg 0 to mem 2
reg[31:0] is14 = 32'b00000000000000000000000000000000; //nope
reg[31:0] is15 = 32'b00000000000000000000000000000000; //nope
THIS IS FOR CHECKING NUMBER OF ONES

reg[31:0] is0 =  32'b00101000100100011001000000000000; //store a = number to evaluate
reg[31:0] is1 =  32'b00010000000000000000000000000000; //load zero into reg 0 for (num_ones)
reg[31:0] is2 =  32'b00010000000000000000000000000001; //load eva_val into reg 1 (from mem 0)
reg[31:0] is3 =  32'b00010100000000000000000000000111; // branch if neg to 7
reg[31:0] is4 =  32'b00110101000000000000000000001010; // branch if zero to 10
reg[31:0] is5 =  32'b01110000000000000001000000000001; // shift reg 1 left by 1
reg[31:0] is6 =  32'b00110000000000000000000000000011; // branch always to 3
reg[31:0] is7 =  32'b01011000000000000001000000000000; // add 1 to reg 0
reg[31:0] is8 =  32'b01110000000000000001000000000001; // shift reg 1 left by 1
reg[31:0] is9 =  32'b00110000000000000000000000000011; // branch always to 3
reg[31:0] is10 = 32'b10000000000000000000000000000000; // HALT
reg[31:0] is11 = 32'b00000000000000000000000000000000; //
reg[31:0] is12 = 32'b00000000000000000000000000000000; //nope
reg[31:0] is13 = 32'b00000000000000000000000000000000; //nope
reg[31:0] is14 = 32'b00000000000000000000000000000000; //nope
reg[31:0] is15 = 32'b00000000000000000000000000000000; //nope
